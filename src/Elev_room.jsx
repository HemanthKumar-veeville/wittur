/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 .\src\assets\elevator_room_building\elev_room.glb 
*/

import React, { useState, useEffect } from "react";
import { useGLTF, useAnimations, useTexture } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import * as THREE from "three";
import ElevRoomScene from "./assets/elevator_room_building/elev_room.glb";

// Import all textures
import MatBaseColor from "./assets/elevator_room_building/textures/material_baseColor.png";
import MatMetallicRoughness from "./assets/elevator_room_building/textures/material_metallicRoughness.png";
import MatNormal from "./assets/elevator_room_building/textures/material_normal.png";
import Mat1BaseColor from "./assets/elevator_room_building/textures/material_1_baseColor.png";
import Mat1MetallicRoughness from "./assets/elevator_room_building/textures/material_1_metallicRoughness.png";
import Mat1Emissive from "./assets/elevator_room_building/textures/material_1_emissive.png";
import Mat1Normal from "./assets/elevator_room_building/textures/material_1_normal.png";

function ElevRoom(props) {
  const group = React.useRef();
  const { nodes, materials, animations } = useGLTF(ElevRoomScene);
  const { actions } = useAnimations(animations, group);

  // Load all textures
  const [
    baseColorTexture,
    metallicRoughnessTexture,
    normalTexture,
    mat1BaseColorTexture,
    mat1MetallicRoughnessTexture,
    mat1EmissiveTexture,
    mat1NormalTexture,
  ] = useTexture([
    MatBaseColor,
    MatMetallicRoughness,
    MatNormal,
    Mat1BaseColor,
    Mat1MetallicRoughness,
    Mat1Emissive,
    Mat1Normal,
  ]);

  // Configure textures
  useEffect(() => {
    // Configure all textures
    [
      baseColorTexture,
      metallicRoughnessTexture,
      normalTexture,
      mat1BaseColorTexture,
      mat1MetallicRoughnessTexture,
      mat1EmissiveTexture,
      mat1NormalTexture,
    ].forEach((texture) => {
      texture.flipY = false;
      texture.encoding = THREE.sRGBEncoding;
    });

    // Apply textures to Mat material
    materials.Mat.map = baseColorTexture;
    materials.Mat.metalnessMap = metallicRoughnessTexture;
    materials.Mat.roughnessMap = metallicRoughnessTexture;
    materials.Mat.normalMap = normalTexture;
    materials.Mat.needsUpdate = true;

    // Apply textures to 01 material
    materials["01"].map = mat1BaseColorTexture;
    materials["01"].metalnessMap = mat1MetallicRoughnessTexture;
    materials["01"].roughnessMap = mat1MetallicRoughnessTexture;
    materials["01"].emissiveMap = mat1EmissiveTexture;
    materials["01"].normalMap = mat1NormalTexture;
    materials["01"].emissiveIntensity = 10.0; // As specified in the GLTF
    materials["01"].emissive = new THREE.Color(1, 1, 1);
    materials["01"].needsUpdate = true;
  }, [
    baseColorTexture,
    metallicRoughnessTexture,
    normalTexture,
    mat1BaseColorTexture,
    mat1MetallicRoughnessTexture,
    mat1EmissiveTexture,
    mat1NormalTexture,
    materials,
  ]);

  // State to track door positions
  const [leftDoorPos1, setLeftDoorPos1] = useState(0);
  const [rightDoorPos1, setRightDoorPos1] = useState(0);
  const [leftDoorPos2, setLeftDoorPos2] = useState(0);
  const [rightDoorPos2, setRightDoorPos2] = useState(0);
  const [isOpen, setIsOpen] = useState(false);

  // Animation parameters
  const doorOpenAmount = 1.2; // How far the doors should open
  const animationSpeed = 0.05;

  // Handle door animation
  useFrame(() => {
    if (isOpen) {
      // Both lifts - Opening animation (doors slide away from center)
      setLeftDoorPos1(Math.min(leftDoorPos1 - animationSpeed, -doorOpenAmount));
      setRightDoorPos1(
        Math.min(rightDoorPos1 + animationSpeed, doorOpenAmount)
      );
      setLeftDoorPos2(Math.min(leftDoorPos2 - animationSpeed, -doorOpenAmount));
      setRightDoorPos2(
        Math.min(rightDoorPos2 + animationSpeed, doorOpenAmount)
      );
    } else {
      // Both lifts - Closing animation (doors slide towards center)
      setLeftDoorPos1(Math.max(leftDoorPos1 + animationSpeed, 0));
      setRightDoorPos1(Math.max(rightDoorPos1 - animationSpeed, 0));
      setLeftDoorPos2(Math.max(leftDoorPos2 + animationSpeed, 0));
      setRightDoorPos2(Math.max(rightDoorPos2 - animationSpeed, 0));
    }
  });

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group
          name="Null"
          position={[0.085, 1.033, -0.013]}
          rotation={[Math.PI / 2, 0, 0]}
          scale={0.01}
        >
          <mesh
            name="L"
            geometry={nodes.L.geometry}
            material={materials["01"]}
            position={[65.821 + leftDoorPos1 * 100, -1.135, 1.92]}
          />
          <mesh
            name="R"
            geometry={nodes.R.geometry}
            material={materials["01"]}
            position={[-83.479 + rightDoorPos1 * 100, -1.135, 1.92]}
          />
          <mesh
            name="BASE"
            geometry={nodes.BASE.geometry}
            material={materials["01"]}
            position={[17.658, 2.27, -3.84]}
          />
        </group>
        <group
          name="Null_1"
          position={[-2.932, 1.033, -0.013]}
          rotation={[Math.PI / 2, 0, 0]}
          scale={0.01}
        >
          <mesh
            name="BASE_2"
            geometry={nodes.BASE_2.geometry}
            material={materials["01"]}
            position={[17.658, 2.27, -3.84]}
          />
          <mesh
            name="L_2"
            geometry={nodes.L_2.geometry}
            material={materials["01"]}
            position={[65.821 + leftDoorPos2 * 100, -1.135, 1.92]}
          />
          <mesh
            name="R_2"
            geometry={nodes.R_2.geometry}
            material={materials["01"]}
            position={[-83.479 + rightDoorPos2 * 100, -1.135, 1.92]}
          />
        </group>
        <mesh
          name="Sweep"
          geometry={nodes.Sweep.geometry}
          material={materials.Mat}
          position={[-1.483, 1.157, -1.051]}
          rotation={[Math.PI / 2, 0, 0]}
          scale={0.01}
        />
      </group>
    </group>
  );
}

useGLTF.preload(ElevRoomScene);

export default ElevRoom;
